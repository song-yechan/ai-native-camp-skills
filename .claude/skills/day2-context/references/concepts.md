# Day 2: 핵심 개념 상세 정리

> 이 문서는 Day 2 스킬의 상세 참조 자료입니다. SKILL.md에서 "자세한 내용은 references/concepts.md 참조"로 안내합니다.

---

## 1. 도구별 설계 철학 완전 가이드

### 왜 설계 철학이 중요한가?

도구마다 **데이터를 구조화하는 방식**이 다릅니다. 이 구조를 이해하면 AI가 그 데이터를 더 정확하게 읽고 활용할 수 있습니다.

핵심 질문 3가지:
1. 어떤 설계 철학으로 만들어졌는가?
2. 그래서 어떤 구조의 맥락이 쌓이는가?
3. AI가 그 구조를 왜 읽을 수 있는가?

### 맥락의 지도

```
┌─ 소통 ─────────────────────────────────────────────┐
│ Slack    채널+스레드      → 토픽별 실시간 맥락       │
│ Gmail    라벨+스레드      → 외부 공식 기록           │
└────────────────────────────────────────────────────┘

┌─ 지식 ─────────────────────────────────────────────┐
│ Notion   블록+DB          → 구조화된 지식           │
│ Drive    파일             → 축적된 산출물           │
└────────────────────────────────────────────────────┘

┌─ 실행 ─────────────────────────────────────────────┐
│ Linear   이슈+스프린트    → 실행 상태               │
│ Calendar 이벤트           → 미래의 구조             │
└────────────────────────────────────────────────────┘
```

---

### 1-1. Slack — "투명한 채널 기반 소통"

**설계 철학**: 이메일의 "푸시" 방식을 "풀" 방식으로 전환

| Before (이메일) | After (Slack) |
|----------------|---------------|
| 보내는 사람이 받는 사람 결정 (푸시) | 받는 사람이 채널을 구독 (풀) |
| CC/BCC 지옥 | 채널 = 맥락의 경계선 |
| 답장 체인 꼬임 | 스레드 = 맥락의 깊이 |

**AI가 읽는 구조**:
- **채널 메인 (1층)** — 무엇이 논의되고 있는지 (스캔용)
- **스레드 (2층)** — 왜 그렇게 결정됐는지 (깊이 분석용)

**AI 활용 예시**: "지난주 #product 채널 논의 요약해줘" → 채널 스캔 → 스레드 분석 → 핵심 추출

**MCP 연결**: Connectors 또는 `claude mcp add slack`
**주요 도구**: `slack_read_channel`, `slack_post_message`

**Slack 내부 KPI**: 2,000개 메시지가 보내진 워크스페이스는 93%가 리텐션 → 메시지 사용량 극대화가 핵심

---

### 1-2. Gmail — "정리하지 말고 검색하라" (Search, not Sort)

**설계 철학**: 폴더 정리 → 검색 중심 패러다임 전환

| Before (Outlook) | After (Gmail) |
|-----------------|---------------|
| 폴더에 정리해야 함 | 검색하면 됨 |
| 하나의 이메일 = 하나의 폴더 | 하나의 이메일 = 여러 라벨 |
| 용량 부족 → 삭제 필요 | 1GB → 절대 삭제하지 마라 |
| 폴더 구조 = 내가 기억해야 | 검색 연산자 = 기계가 찾아줌 |

**AI가 읽는 구조**:
- **라벨** = 다차원 메타데이터: `[project-alpha] + [budget] + [from-cfo]` → 여러 축으로 검색
- **검색 연산자** = 구조화된 쿼리: `from:cfo subject:budget after:2024/01` → AI가 연산자를 직접 조합
- **스레드** = 의사결정 기록: "Q3 예산이 어떻게 결정됐어?" → 스레드 전체 분석

**연결**: API 스크립트 (Claude가 작성)

---

### 1-3. Notion — "Everything is a Block"

**설계 철학**: 비구조 텍스트 → 타입이 있는 블록 기반 데이터

| Before (Word/Google Docs) | After (Notion) |
|--------------------------|----------------|
| 텍스트 + 서식 (비구조) | 타입이 있는 블록 (구조) |
| `- [ ] 할 일` = 그냥 텍스트 | `to_do` 블록 = 시맨틱하게 "할 일" |
| 추출하려면 NLP 필요 | 블록 타입으로 바로 쿼리 |
| 문서 단위로만 접근 | 블록 단위로 접근 가능 |

**AI가 읽는 구조**:
- **블록** = 타입이 있는 구조화된 데이터 → API 한 번으로 특정 타입 쿼리
- **데이터베이스** = 필터 가능한 메타데이터 → `Status=진행중 & Owner=Alice` 바로 필터
- **Relations** = 지식 그래프 → Meeting → Project → Team → OKR 관계를 따라가면서 맥락 확장

**MCP 연결**:
- Connectors (가장 쉬움)
- `claude mcp add --transport http notion https://mcp.notion.com/mcp`

**참고**: MCP 월간 검색량 9,500회 (비개발 도구 중 1위)

---

### 1-4. Google Drive — "파일 + 실시간 공동편집 + 클라우드"

**설계 철학**: 물리적 파일 → 클라우드 공유 + 동시 편집

| Before (USB 시대) | After (Google Drive) |
|-------------------|---------------------|
| 파일을 물리적으로 옮김 | 링크 하나로 공유 |
| 한 사람만 편집 가능 | 실시간 다중 편집 |
| 버전 관리 수동 | 자동 버전 히스토리 |
| 로컬 저장 → 분실 위험 | 클라우드 → 어디서든 접근 |

**AI가 읽는 맥락**: "지금까지 뭘 만들어왔는지" — 보고서, 제안서, 스프레드시트 등 **축적된 산출물 아카이브**

**Notion과의 차이**:
- Notion = 구조화된 지식 (AI가 바로 쿼리)
- Drive = 비구조화된 파일 (AI가 열어서 읽어야 함)

**연결**: Connectors 또는 API 스크립트

---

### 1-5. Linear/Jira — "애자일 방법론 구현"

**설계 철학**: 작업 추적 및 실행 구조화

**AI가 읽는 구조**:
- **이슈** = 구조화된 데이터 (실행 상태)
- **스프린트** = 시간 범위가 있는 작업 묶음

**AI 활용 예시**: "스프린트 현황 어때?" → 바로 필터링 가능

**MCP 연결**: Connectors 또는 명령어

---

### 1-6. Google Calendar — "미래의 시간 자원 구조화"

**설계 철학**: 일정 관리 및 공유

**AI가 읽는 구조**:
- **이벤트** = `{ 제목, 시간, 참석자, 설명, 반복여부 }` = 미래의 구조화된 데이터

**Calendar의 특별함**:
> 다른 모든 도구는 **과거와 현재**를 담는다.
> Calendar만 **미래**를 담는다.
> → 크로스 도구 검색의 **시작점**이 된다.

**연결**: API 스크립트 (Claude가 작성)

---

### 도구별 설계 철학 요약

| 도구 | 핵심 설계 철학 | AI가 읽는 맥락 |
|------|---------------|---------------|
| Slack | 투명한 채널 기반 소통 | 채널 = 경계선, 스레드 = 깊이 |
| Gmail | 정리하지 말고 검색하라 | 라벨 = 메타데이터, 스레드 = 기록 |
| Notion | Everything is a Block | 블록 = 구조화 데이터, DB = 쿼리 |
| Drive | 파일 공유 + 공동 편집 | 축적된 산출물 아카이브 |
| Linear | 애자일 방법론 구현 | 이슈 = 실행 상태 |
| Calendar | 미래의 시간 자원 구조화 | 이벤트 = 미래의 구조 |

---

## 2. MCP 완전 가이드

### 정의

**MCP (Model Context Protocol)** = AI가 외부 서비스와 대화하는 **표준 규약**

**비유**: USB-C 포트
- 옛날: 기기마다 다른 포트 → 전용 케이블 필요
- 지금: USB-C 하나로 다 연결 → 표준 케이블 하나
- MCP: 도구마다 다른 API → MCP라는 표준 규격으로 통일

### 작동 원리

```
사용자: "Slack에서 #general 채널 메시지 읽어줘"
    │
    ▼
Claude: "Slack MCP 서버에 요청할게요"
    │
    ▼  MCP 프로토콜 (표준 규격)
    │
Slack MCP 서버: Slack API 호출 → 메시지 조회
    │
    ▼
Claude: "최근 메시지 10개입니다: ..."
```

핵심:
- Claude는 **MCP 프로토콜만** 알면 됨
- 각 도구의 API 세부사항은 **MCP 서버가 처리**
- 사용자는 **자연어로 요청**만 하면 됨

### 연결 방법 3가지

#### 방법 1: Connectors (가장 쉬움, 추천)
- `claude.ai/settings/connectors`에서 **클릭으로 연결**
- 코드 한 줄 없이 버튼만 누르면 됨
- 지원: Slack, Notion, Google Drive, Linear 등

#### 방법 2: 명령어
```bash
# Notion 연결
claude mcp add --transport http notion https://mcp.notion.com/mcp

# Slack 연결
claude mcp add slack

# 연결 확인
/mcp
```
- 터미널에서 한 줄이면 연결 완료
- Claude에게 "Notion MCP 연결해줘"라고 말해도 됨

#### 방법 3: 수동 설정 (.mcp.json)
- 프로젝트 루트에 `.mcp.json` 파일 직접 편집
- 세밀한 설정이 필요할 때 사용
- Claude가 대신 작성해줄 수 있음

### 확인 방법

```
/mcp

출력 예시:
┌─────────────────────────────────────────────────┐
│ Connected MCP Servers:                          │
│                                                 │
│ ✅ slack (connected)                            │
│    Tools: slack_read_channel, slack_post_message │
│                                                 │
│ ✅ notion (connected)                           │
│    Tools: query_database, create_page           │
│                                                 │
│ ❌ gmail (disabled)                             │
└─────────────────────────────────────────────────┘
```

### 관리 명령어

| 명령어 | 설명 |
|--------|------|
| `claude mcp disable [서버명]` | 비활성화 |
| `claude mcp enable [서버명]` | 다시 활성화 |
| `/mcp` | 연결 상태 확인 |

### 컨텍스트 관리 팁

**주의**: MCP 도구가 많으면 컨텍스트 토큰을 많이 소비합니다.

**해결책**:
1. 자주 쓰는 도구만 연결
2. 안 쓰는 MCP는 `disable`
3. **Lazy Loading** 설정: 컨텍스트가 10% 넘어가면 필요할 때만 연결 (고급 설정)

**모범 사례**:
- ✅ 자주 쓰는 도구만 연결
- ✅ `/mcp`로 연결 상태 주기적 확인
- ✅ 문제 있으면 disable → 다시 enable
- ❌ 모든 도구를 한꺼번에 연결
- ❌ 사용하지 않는 연결 방치

---

## 3. Context Sync 스킬 완전 가이드

### 정의

여러 도구에서 정보를 **자동 수집**하여 **하나의 문서**로 정리하는 스킬

**Before**: 매일 아침 30분 — Slack → Gmail → Calendar → Notion 하나씩 열어서 확인, 결국 정리 안 됨
**After**: "싱크해줘" → 1분 후 오늘의 컨텍스트가 하나의 문서로 정리됨

### 스킬 구조

```
.claude/skills/my-context-sync/
├── SKILL.md          # 스킬 본체
├── scripts/          # 수집 스크립트 (Gmail, Calendar 등)
│   ├── gmail_fetch.py
│   └── calendar_fetch.py
└── references/       # 참고 문서
```

### SKILL.md 구조 예시

```markdown
---
name: my-context-sync
description: 나의 컨텍스트 싱크. "싱크", "sync" 요청에 사용.
---

# My Context Sync

## 소스 정의
- Slack: #general, #project-updates
- Notion: 업무 태스크 DB
- Calendar: 오늘 ~ 7일 후

## 실행 흐름
1. 병렬 수집 (Subagent)
2. 결과 통합
3. 문서 저장

## 출력
sync/YYYY-MM-DD-context-sync.md
```

### 구축 단계 (Block 0~5)

| Block | 내용 | 시간 |
|-------|------|------|
| Block 0 | 도구 선택 + 스킬 골격 생성 | 5분 |
| Block 1 | Explore 에이전트로 프로젝트 탐색 | 5분 |
| Block 2 | MCP/API로 도구 연결 | 5분 |
| Block 3 | Subagent로 병렬 수집 + 검증 | 10분 |
| Block 4 | Output 형식 설정 (Markdown/Slack/Notion) | 5분 |
| Block 5 | 완성 + 실행 테스트 | 5분 |

### 직종별 추천 도구 조합

| 직종 | 추천 조합 |
|------|----------|
| PM/기획자 | Slack + Linear/Jira + Calendar |
| 마케터 | Slack + Gmail + 소셜미디어 |
| 영업 | Gmail + Calendar + CRM |
| CEO/리더 | Slack + Calendar + 뉴스/RSS |
| 디자이너 | Slack + Notion + Figma |
| 개발자 | Slack + GitHub + Linear |

**팁**: 2~4개 도구로 시작 → 나중에 언제든 추가

### Output 옵션

1. **Markdown 파일** (기본, 추천) — `sync/YYYY-MM-DD-context-sync.md`에 저장
2. **Slack 메시지** — 지정한 채널에 요약 메시지 전송
3. **Notion 페이지** — 지정한 데이터베이스에 페이지 생성

### 활용 팁

1. **매일 아침 실행** → "모닝 브리핑"으로 하루 시작
2. **CLAUDE.md에 스케줄 추가** → 자동 실행 가능
3. **소스 추가** → 스킬 파일 수정으로 언제든 가능
4. **Day 3 이후 발전** → Clarify로 조건 분기 + 더 복잡한 워크플로우

---

## 4. Subagent 병렬 수집

### Subagent란?

메인 Claude가 **다른 Claude를 불러서 작업을 위임**하는 것

**비유**: 부하 직원에게 일 맡기기 — "이거 해놓고 끝나면 알려줘" → 나는 다른 일 하고 있으면 됨

### 병렬 수집이 가능한 이유

Slack, Notion, Calendar는 서로 **의존성이 없음** → 각각 독립적으로 수집 가능 → 동시에 실행하면 시간 절약

### 작동 방식

```
사용자: "싱크해줘"
    │
    ▼
메인 Claude: "3개 Subagent 실행"
    │
    ├─ Subagent 1 ─── Slack 수집
    ├─ Subagent 2 ─── Notion 수집
    └─ Subagent 3 ─── Calendar 수집
    │
    ▼ (3개 동시 실행)
    │
메인 Claude: 결과 통합 → 문서 생성
```

### 주의 사항

- 각 Subagent **결과가 너무 크면** 정보 손실 가능
- **추천**: Subagent가 파일로 저장 → 메인이 파일 읽기 방식
- 토큰 효율을 위해 **요약만 반환**하도록 설정

### Context Sync에서의 활용 예시

```
"Task 도구로 subagent 실행:
 - Slack: 최근 7일 #general 채널 메시지 수집
 - Notion: 진행 중인 태스크 수집
 - Calendar: 이번 주 일정 수집

 각 결과를 파일로 저장 후 통합"
```

---

## 5. 맥락 문제의 본질

### 핵심 질문
"같은 AI인데, 왜 결과가 다를까?"

### 답
**맥락의 유무**가 AI 결과의 질을 결정합니다.

### 예시: "다음 주 미팅 안건 만들어줘"

**맥락 없이**: "1. 진행 상황 업데이트 2. 이슈 논의 3. 다음 계획" (어떤 팀에나 같은 결과)

**6개 도구가 연결된 AI**:
- [Linear] 스프린트 8 완료율 72%, 블로커 2건
- [Slack] #product에서 결제 UX 논의 미결
- [Gmail] 고객사 A SLA 회신 대기 (3일째)
- [Notion] PRD v2 미완료 태스크 4건
- [Calendar] 수요일 디자인 리뷰 → 시안 사전 공유 필요
- [Drive] Q4 보고서 초안 — 리뷰 필요

### 문제
이 맥락을 AI에게 **매번 복사-붙여넣기**? → 5분이면 지침 → 결국 안 하게 됨

### 해법
- **연결하는 방법** = MCP (도구를 AI에 직접 연결)
- **자동화하는 방법** = Context Sync 스킬 ("싱크해줘" 한마디)

---

## 6. 캠프 전체 흐름에서의 Day 2 위치

```
Day 1: CLAUDE.md = 내 맥락을 설계 (Context 설계)
Day 2: MCP 연결 = 외부 도구의 맥락을 연결 (Context 확장) ← 오늘
Day 3: 스킬 = 맥락 기반 워크플로우 (Context 활용)
Day 4: 문서화 + 자동화 = 만든 걸 복리로 키우는 법

"프롬프트 잘 쓰는 법을 배운 게 아닙니다.
 AI가 참고할 맥락 전체를 설계한 겁니다."
```
