---
name: day4-compound
description: "AI Native Camp Day 4 — 시스템화: Compound Engineering으로 복리 성장. '/day4', 'Compound', '시스템화' 요청 시 사용."
---

# Day 4: 시스템화 — 만든 걸 복리로 키우는 법

> **테마**: Context Engineering + Compound Engineering
> **핵심 메시지**: "한 번 만들고 끝이 아니다. 쓰면서 고치면 복리로 성장한다."
> **예상 소요**: 약 75분
> **사전 과제**: Day 3 스킬 제작 완료 (또는 시도)
> **산출물**: 개선된 CLAUDE.md + 1주 목표 설정

---

## 진행 가이드 (Claude가 따를 지시)

### 인터랙션 규칙
1. **한 블록씩 순서대로** 진행한다. 블록을 건너뛰지 않는다.
2. 각 블록의 **EXPLAIN → EXECUTE → QUIZ** 순서를 지킨다 (없는 단계는 생략).
3. EXPLAIN은 **핵심 비유와 개념만 압축**해서 전달한다. 상세 내용은 "references/concepts.md 참조"로 안내한다.
4. EXECUTE는 사용자가 **직접 따라할 수 있도록** 구체적 명령어와 기대 결과를 보여준다.
5. QUIZ는 **AskUserQuestion** tool로 객관식 3문항을 출제한다. 정답 시 다음 블록, 오답 시 해설 후 재시도.
6. 각 블록 완료 후 **"다음 블록으로 넘어갈까요?"** 라고 물어보고 사용자 응답을 기다린다.
7. 모든 응답은 **한국어**로 한다.
8. 사용자가 "다음", "넘어가자", "계속" 등으로 응답하면 다음 블록을 시작한다.
9. 사용자가 "자세히", "더 알려줘" 라고 하면 references/concepts.md의 해당 섹션을 읽어서 상세 설명한다.

### 진행 상태 표시
각 블록 시작 시 아래 형식으로 진행 상태를 보여준다:
```
📍 Day 4 진행: [Block N/5] — 블록 제목
```

---

## Block 0: Context Engineering — 이 캠프의 정체

### EXPLAIN

📍 Day 4 진행: [Block 0/5] — Context Engineering

**4일의 여정을 돌아보면:**

| Day | 활동 | Context Engineering 관점 |
|-----|------|-------------------------|
| Day 1 | CLAUDE.md 작성 | Context **설계** |
| Day 2 | MCP 연결 | Context **확장** |
| Day 3 | 스킬 제작 | Context **활용** |
| Day 4 | 쓰면서 고치기 | Context **개선** (오늘) |

> "프롬프트 잘 쓰는 법을 배운 게 아닙니다.
> AI가 참고할 맥락 전체를 설계한 겁니다. **이미 하고 있었어요.**"

**Context Engineering이란?**

AI가 참고할 맥락 전체를 설계하고 관리하는 기술

**진화 과정:**
- 2023: Prompt Engineering — 프롬프트를 잘 쓰면 된다
- 2024: RAG, Few-shot — 프롬프트 + 맥락 구성
- 2025~: **Context Engineering** — 맥락 자체를 설계/관리

**업계가 발견한 3가지 교훈:**
1. **프롬프트가 아니라 데이터가 문제** — CLAUDE.md가 부정확하면 결과도 부정확
2. **계획 리뷰 > 결과 리뷰** — 2,000줄 결과물보다 200줄 계획을 리뷰하는 게 효율적
3. **한번 설계하면 매번 효과** — 맥락을 한번 잘 설계하면 "대충 물어봐도" AI가 잘 답한다

**핵심 공식:**
- AI 모델 = 순수 함수 (Pure Function)
- 출력의 품질을 결정하는 건 오직 **입력의 품질**
- Garbage In, Garbage Out

> 상세 내용은 `references/concepts.md` 섹션 1을 참조하세요.

### QUIZ

**Q1. Day 1~3에서 우리가 실제로 해온 것은?**
- (A) 프로그래밍 학습
- (B) AI 모델 학습
- (C) Context Engineering (맥락 설계/확장/활용) ✅
- (D) 데이터 분석

해설: CLAUDE.md(설계) → MCP(확장) → 스킬(활용)은 모두 AI가 참고할 맥락을 다루는 Context Engineering이었습니다.

**Q2. "계획 리뷰가 결과 리뷰보다 효율적"인 이유는?**
- (A) 계획이 더 짧아서 읽기 쉬우니까
- (B) 200줄 계획을 잡아야 2,000줄 결과물의 방향을 통제할 수 있으니까 ✅
- (C) 결과물은 리뷰할 필요가 없어서
- (D) 계획에는 오류가 없어서

해설: AI에게 먼저 계획을 세우게 하고 계획을 검토하면, 잘못된 방향으로 2,000줄을 쓰는 것을 방지합니다.

**Q3. Context Engineering에서 "입력의 품질"이란?**
- (A) 타이핑 속도
- (B) CLAUDE.md, MCP, 스킬 등 AI에게 제공하는 맥락의 질 ✅
- (C) 컴퓨터 사양
- (D) 인터넷 속도

해설: AI 모델은 순수 함수입니다. 맥락(입력)의 품질이 결과(출력)의 품질을 결정합니다.

---

## Block 1: Compound Engineering — 복리의 힘

### EXPLAIN

📍 Day 4 진행: [Block 1/5] — Compound Engineering

**Compound Engineering = 쓰면서 고치면 복리로 성장하는 것**

**기존 방식 vs Compound 방식:**

| 기존 방식 | Compound 방식 |
|----------|--------------|
| AI에게 일 시킴 → 실수 → 채팅으로 고쳐달라고 함 → **다음에 또 같은 실수** | AI가 실수 → "왜?" 원인 파악 → CLAUDE.md에 규칙 추가 → **다음부터 그 실수 안 함** |

**풀 사이클 6단계:**

```
Build    → 일단 만든다
Use      → 실제로 써본다
Notice   → 불편함을 발견한다
Debug    → 원인을 찾는다
Fix      → 한 가지만 고친다
Document → 기록한다
→ (다시 Use로 돌아가서 반복)
```

**핵심: 한번에 100% 만드는 게 아니라, 1%씩 100번 개선하는 것. 이게 복리입니다.**

**구체적 이득 3가지:**
1. **같은 말을 반복하지 않아도 됨** — CLAUDE.md에 한번 적으면 영원히 적용
2. **혼자서도 팀만큼 결과** — 약한 모델 + 좋은 워크플로우(95.1%) > 강한 모델 단독(67.0%)
3. **미래 핵심 역량** — Microsoft 2025: 글로벌 리더 82%가 AI 에이전트 도입 예정

> 상세 내용은 `references/concepts.md` 섹션 2를 참조하세요.

### QUIZ

**Q1. Compound Engineering의 핵심 철학은?**
- (A) 완벽하게 만들어서 한 번에 완성
- (B) 일단 만들고, 쓰면서 계속 고치면 복리 성장 ✅
- (C) 여러 사람이 함께 만들기
- (D) AI에게 모든 것을 맡기기

해설: "잘 만들어서 완성하면 끝" ✕ → "일단 만들고 쓰면서 계속 고치면 복리" ✓

**Q2. 풀 사이클에서 "Notice" 단계의 역할은?**
- (A) 코드를 작성하는 단계
- (B) 불편함을 발견하는 단계 ✅
- (C) 결과를 발표하는 단계
- (D) 팀에 공유하는 단계

해설: Notice는 실제로 써보면서 불편한 점을 발견하는 단계입니다. 이 불편함이 개선의 신호입니다.

**Q3. "약한 모델 + 좋은 워크플로우"가 "강한 모델 단독"보다 나은 이유는?**
- (A) 비용이 저렴해서
- (B) 워크플로우가 맥락과 구조를 제공하여 결과 품질을 높이므로 ✅
- (C) 약한 모델이 더 빨라서
- (D) 강한 모델은 오류가 많아서

해설: 워크플로우(스킬, CLAUDE.md 등)가 제공하는 구조화된 맥락이 모델 성능 차이를 뛰어넘습니다.

---

## Block 2: GitHub 기초

### EXPLAIN

📍 Day 4 진행: [Block 2/5] — GitHub 기초

**"기록 없이는 복리가 안 된다"**

CLAUDE.md, 스킬, MCP 설정도 한 줄 바꾸면 결과가 달라집니다. 변경을 기록하고 되돌릴 수 있어야 복리 효과를 얻습니다.

**GitHub 핵심 기능 4가지:**

| 기능 | 비유 | 설명 |
|------|------|------|
| **Repository** | 프로젝트의 집 | 모든 파일이 사는 곳 |
| **Commit** | 게임 세이브 | 잘 되는 시점에 저장 + 왜 바꿨는지 메모 |
| **Branch** | 실험용 복사본 | 원본 안 건드리고 시도 |
| **Pull Request** | 결재 문서 | "이렇게 바꿔봤는데 봐줘" |

**git 명령어 비유:**

| 명령어 | 비유 |
|--------|------|
| git clone | Google Drive에서 폴더 다운로드 |
| git commit | 게임 세이브 |
| git branch | A안, B안 동시 작업 |
| git push | Google Drive에 업로드 |

> 명령어를 외울 필요 없습니다. Claude에게 말로 시키면 됩니다.
> 상세 내용은 `references/concepts.md` 섹션 3을 참조하세요.

---

## Block 3: 서비스화 — 스킬을 서비스로

### EXPLAIN

📍 Day 4 진행: [Block 3/5] — 서비스화

**스킬 vs 서비스:**

| 구분 | 스킬 | 서비스 |
|------|------|--------|
| 비유 | 내 노트북의 글 초안 | 블로그에 발행한 글 |
| 접근성 | 나만 사용 | 누구나 접속 가능 |
| 특징 | 로컬 동작 | URL + 데이터 + API |

**3가지 인프라:**

| 인프라 | 비유 | 역할 |
|--------|------|------|
| **GitHub** | 작가의 작업실 | 버전 기록 + 협업 |
| **Vercel** | 자동 발행 시스템 | GitHub에 올리면 → 자동 웹사이트 |
| **Supabase** | 독자 관리 + 데이터 | 방문자, 검색, API |

**서비스화 플로우:**
```
스킬 (나만 쓰는 것)
    ↓ "다른 사람도 쓸 수 있게 만들고 싶다"
서비스화 = 스킬에 "살"을 붙이는 것
  • 웹 인터페이스 (Vercel)
  • 데이터 저장 (Supabase)
  • 버전 관리 (GitHub)
    ↓
실제 서비스!
```

> 지금 당장 서비스화할 필요는 없습니다. 개념만 이해하면 됩니다.
> 상세 내용은 `references/concepts.md` 섹션 4를 참조하세요.

### QUIZ

**Q1. Vercel의 역할을 가장 잘 설명한 것은?**
- (A) 데이터를 저장하는 곳
- (B) GitHub에 올리면 자동으로 웹사이트로 배포하는 시스템 ✅
- (C) 코드를 작성하는 도구
- (D) 이메일을 보내는 서비스

해설: Vercel은 GitHub에 코드를 올리면 자동으로 웹사이트로 배포해주는 "자동 발행 시스템"입니다.

**Q2. 스킬과 서비스의 가장 큰 차이는?**
- (A) 파일 형식
- (B) 나만 사용 vs 누구나 접속 가능 ✅
- (C) 프로그래밍 언어
- (D) 실행 속도

해설: 스킬은 로컬에서 나만 쓰는 것, 서비스는 URL로 누구나 접속할 수 있는 것입니다.

**Q3. 비개발자가 서비스화를 할 때 가장 좋은 방법은?**
- (A) 직접 코드를 학습하여 구현
- (B) Claude에게 말로 시켜서 구현 ✅
- (C) 외부 개발자를 고용
- (D) 서비스화를 포기

해설: Claude에게 "Vercel에 배포해줘", "Supabase에 연결해줘"라고 말하면 됩니다.

---

## Block 4: Compound 사이클 실습

### EXPLAIN

📍 Day 4 진행: [Block 4/5] — Compound 사이클 실습

이제 직접 Compound Engineering 사이클을 한 바퀴 돌려봅니다.

**오늘 할 일은 딱 하나: 사이클을 한 바퀴 돌리는 것.**

### EXECUTE

**실습 A: CLAUDE.md 규칙 추가 (필수, 15분)**

**Step 1: Notice (불편함 발견) — 3분**

사용자에게 AskUserQuestion으로 질문:
- "Day 1~3 동안 Claude에게 매번 반복해서 말한 것이 있었나요? (예: 한국어로 답해줘, 표로 정리해줘, 존댓말로 해줘 등)"

**Step 2: Debug (원인 파악) — 2분**

```
💡 왜 매번 말해야 했을까요?
→ CLAUDE.md에 해당 규칙이 없었기 때문입니다!
```

**Step 3: Fix (규칙 추가) — 5분**

Claude에게 요청:
```
CLAUDE.md에 다음 규칙을 추가해줘: [사용자가 답변한 반복 내용]
```

**Step 4: Document (기록) — 2분**
```
방금 추가한 규칙이 뭔지 CLAUDE.md에서 확인해줘
```

**Step 5: 효과 확인 — 3분**

`/clear` 로 새 대화를 시작한 후, 아무 질문이나 해서 규칙이 적용되는지 확인합니다.

```
🎉 축하합니다! 사이클을 한 바퀴 돌렸습니다.
   여러분은 이미 Compound Engineering을 하고 있습니다.
```

---

**실습 B: 스킬 출력 수정 (선택, 5분)**

Day 3에서 만든 스킬이 있다면:

1. **Use** — 스킬 실행
2. **Notice** — 출력 중 마음에 안 드는 부분 발견
3. **Fix** — "이 스킬의 출력 포맷을 [원하는 형식]으로 바꿔줘"
4. **Use Again** — 수정된 결과 확인

---

## Block 5: 마무리 — 1주 목표 설정

### EXPLAIN

📍 Day 4 진행: [Block 5/5] — 마무리

### 오늘 배운 것 정리

| 개념 | 핵심 |
|------|------|
| Context Engineering | 프롬프트가 아니라 **맥락을 설계**하는 것 |
| Compound Engineering | 쓰면서 고치면 **복리로 성장** |
| 풀 사이클 | Build → Use → Notice → Debug → Fix → Document |
| GitHub 기초 | Repository, Commit, Branch, PR — **기록의 인프라** |
| 서비스화 | GitHub + Vercel + Supabase로 스킬을 서비스로 확장 |

### 4일간의 여정 요약

```
Day 1: CLAUDE.md     = Context 설계     ✅
Day 2: MCP 연결      = Context 확장     ✅
Day 3: 스킬 제작     = Context 활용     ✅
Day 4: 복리로 키우기 = Context 개선     ✅ (오늘)
```

### EXECUTE

**1주 목표 설정**

사용자에게 AskUserQuestion으로 질문:
- "1주일 후 최종 발표에서 보여줄 목표를 설정해주세요. 템플릿: '1주일 후, 나는 [____]를 보여줄 수 있다'"

**목표 작성 가이드:**
- 구체적으로: "주간 업무 요약 스킬이 Slack + Gmail 데이터를 가져온다"
- 측정 가능하게: "동작하는 영상을 녹화할 수 있다"
- 현실적으로: "한 가지 업무가 자동화된다"

**목표 기록:**

사용자 답변을 받은 후:
```
CLAUDE.md에 '1주 목표' 섹션을 추가해줘.
목표: [사용자 답변]
```

### 오늘의 산출물
- 개선된 CLAUDE.md (새 규칙 추가)
- 1주 목표 설정 완료

### 1주일 동안 할 일
1. **만든 것 실제로 써보기** — CLAUDE.md, 스킬을 실제 업무에 적용
2. **불편한 점 발견하면 고치기** — Compound Engineering 사이클 반복
3. **최종 발표 준비** — 동작하는 영상 또는 링크 준비

### 핵심 메시지

> "4일 동안 세 가지를 만들었습니다.
> CLAUDE.md, MCP 연결, 스킬.
>
> 오늘 배운 건 이것들을 **내 마음에 들게** 만드는 법입니다.
>
> 쓰고, 고치고, 쌓으세요.
> **그게 복리입니다.**"

---

> AI Native Camp 4일 과정을 모두 완료했습니다! 🎉
> 1주 후 최종 발표에서 여러분의 결과물을 기대합니다.
