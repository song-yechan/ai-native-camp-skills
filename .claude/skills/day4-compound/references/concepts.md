# Day 4 핵심 개념 상세 — 시스템화: 만든 걸 복리로 키우는 법

> 이 문서는 Day 4 강의의 핵심 개념을 정리한 레퍼런스입니다.
> SKILL.md의 EXPLAIN 블록에서 "상세는 references/concepts.md 참조"로 안내합니다.

---

## 1. Context Engineering 완전 가이드

### 1.1 정의

**Context Engineering**이란 AI가 참고할 맥락 전체를 설계하고 관리하는 기술이다.
Prompt Engineering의 확장 개념으로, 단일 프롬프트가 아닌 **맥락 전체의 구조**를 다룬다.

### 1.2 진화 과정

| 시기 | 패러다임 | 핵심 |
|------|----------|------|
| 2023 | Prompt Engineering | 프롬프트를 잘 쓰면 된다 |
| 2024 | RAG, Few-shot | 프롬프트 + 맥락 구성 |
| 2025~ | Context Engineering | 맥락 자체를 설계/관리 |

### 1.3 AI Native Camp에서의 적용

이 캠프는 처음부터 Context Engineering이었다:

| Day | 활동 | Context Engineering 관점 |
|-----|------|-------------------------|
| Day 1 | CLAUDE.md 작성 | Context **설계** — 내 맥락을 구조화 |
| Day 2 | MCP 연결 | Context **확장** — 외부 도구의 맥락을 연결 |
| Day 3 | 스킬 제작 | Context **활용** — 맥락 기반 워크플로우 |

> "프롬프트 잘 쓰는 법을 배운 게 아닙니다. AI가 참고할 맥락 전체를 설계한 겁니다."

### 1.4 업계가 발견한 세 가지 교훈

**교훈 1: 프롬프트가 아니라 데이터가 문제**
- CLAUDE.md가 부정확하면 AI 결과도 부정확
- 입력 품질 = 출력 품질 (Garbage In, Garbage Out)

**교훈 2: 계획 리뷰가 결과 리뷰보다 효율적**
- 2,000줄 결과물을 리뷰하는 것보다 200줄 계획을 리뷰하는 게 낫다
- AI에게 먼저 계획을 세우게 하고 → 계획을 검토 → 실행

**교훈 3: 한번 설계하면 매번 효과**
- 맥락을 한번 잘 설계하면 "대충 물어봐도" AI가 잘 답한다
- LangChain 2025 조사 (1,340명): 품질 문제의 32%가 AI 능력 부족이 아니라 **맥락 관리 실패**

### 1.5 지식의 저주 (Curse of Knowledge)

**Stanford Newton 실험 (1990)**
- 120곡을 손가락으로 두드려서 상대방에게 맞히게 함
- 두드리는 사람 예측: 50% → 실제 정답률: 2.5% → **20배 과대평가**

**MIT Sloan 연구**
- "전문가는 자기 도메인에서 비전문가보다 더 나쁜 커뮤니케이터"

**IDC 조사**
- 직원 전문 스킬의 42%는 본인만 알고 있음
- F500 연간 지식 공유 실패 비용: $31.5B

> 핵심: 내가 아는 맥락을 AI도 안다고 착각하면 안 된다. **명시적으로 전달**해야 한다.

### 1.6 역할의 변화: 타이피스트에서 매니저로

| 과거 | 지금 |
|------|------|
| 직접 타이핑하는 사람 | AI를 관리하는 사람 |
| 직접 문서 쓰고, 직접 분석하고, 직접 코드 짬 | 계획을 세워주고, 결과물을 검토하고, 피드백하고 승인 |

- **Context Engineering** = AI가 참고할 맥락을 설계하는 것 (설계)
- **Compound Engineering** = 그 맥락을 쓰면서 계속 개선하는 것 (반복)

> "설계만 하고 안 고치면 낡아갑니다. 고치는 과정이 복리입니다."

---

## 2. Compound Engineering 완전 가이드

### 2.1 정의

**Compound Engineering**이란 AI에게 일을 시킬 때마다 AI를 더 똑똑하게 만들어 업무 효율을 **복리(Compound Interest)** 처럼 불리는 방법이다.

### 2.2 핵심 철학

```
기존 방식: "잘 만들어서 → 완성하면 → 끝" ✕
우리 방식: "일단 만들고 → 쓰면서 → 계속 고치면 → 복리" ✓
```

**기존 방식의 문제:**
- AI에게 일 시킴 → AI가 실수 → 채팅으로 고쳐달라고 함 → 다음에 또 같은 실수 반복

**Compound 방식:**
- AI가 실수 → "왜 실수했어?" 원인 파악 → CLAUDE.md에 규칙 추가 → 다음부터는 그 실수 안 함

### 2.3 풀 사이클 6단계

```
Build  → 일단 만든다
  ↓
Use    → 실제로 써본다
  ↓
Notice → 불편함을 발견한다
  ↓
Debug  → 원인을 찾는다
  ↓
Fix    → 한 가지만 고친다
  ↓
Document → 기록한다
  ↓
(다시 Use로 → 사이클 반복)
```

**핵심 원칙:**
- 한번에 100% 만드는 게 아니라, **1%씩 100번 개선**하는 것
- 이것이 복리다

### 2.4 구체적 이득 3가지

**이득 1: 같은 말을 반복하지 않아도 된다**
- "한국어로 답해줘" 매번 말하는 건 비효율
- CLAUDE.md에 한번 적으면 영원히 적용

**이득 2: 혼자서도 팀만큼의 결과를 낸다**
- 약한 모델 + 좋은 워크플로우 (95.1%) > 강한 모델 단독 (67.0%)
- BCG 연구: 품질 +40%

**이득 3: 미래 핵심 역량이 된다**
- Microsoft 2025: 글로벌 리더 82%가 AI 에이전트를 팀원으로 도입 예정

### 2.5 문서화가 성과를 만든다

**Google DORA 2023 연구:**
- 질 높은 내부 문서화 → 조직 성과에 **12.8배** 영향

**AI 시대의 문서화:**
- AI는 코드보다 문서화 품질을 가장 크게 개선 (+7.5%)
- CLAUDE.md, 스킬 설명, MCP 설정 — 다 "문서"이다

### 2.6 Context vs Compound

| 구분 | Context Engineering | Compound Engineering |
|------|-------------------|---------------------|
| 역할 | 맥락을 **설계**하는 것 | 맥락을 쓰면서 **개선**하는 것 |
| 시점 | 처음 한 번 | 매번 반복 |
| 비유 | 설계도 그리기 | 설계도를 써보고 수정하기 |

### 2.7 오늘의 핵심 3줄

1. 만든 것의 가치는 **완성도가 아니라 반복 횟수**에 있다 (복리)
2. 불편함은 버그가 아니라 **개선의 신호**다 (풀 사이클)
3. 사이클을 **한 바퀴 돌린 사람**은 이미 Compound Engineering을 하고 있다

---

## 3. GitHub 완전 가이드 (비개발자용)

### 3.1 GitHub이란?

**한 줄 정의:** 저장 + 공유 + 변경 이력 + 협업 리뷰 플랫폼

- Google Drive의 "변경 이력 + 협업" 강화 버전
- 2025년 기준 1.8억 명 사용
- 코드뿐 아니라 CLAUDE.md, 스킬, MCP 설정도 관리 가능

### 3.2 왜 필요한가?

- CLAUDE.md, 스킬, MCP 설정도 한 줄 바꾸면 결과가 달라짐
- 모든 변경을 기록하고, 되돌릴 수 있어야 함
- **"기록 없이는 복리가 안 된다"**

### 3.3 핵심 기능 4가지

| 기능 | 비유 | 설명 |
|------|------|------|
| **Repository** | 내 프로젝트의 집 | CLAUDE.md, 스킬, MCP 설정이 사는 곳 |
| **Commit** | 게임 세이브 포인트 | 잘 되는 시점에 저장 + 왜 바꿨는지 메모 |
| **Branch** | 원본 안 건드리고 실험하는 복사본 | 원본(main)은 항상 안전 |
| **Pull Request** | "이렇게 바꿔봤는데 봐줘" | 합치기 전 검토 요청 |

### 3.4 git 명령어 비유

| 명령어 | 비유 |
|--------|------|
| `git clone` | Google Drive에서 폴더 다운로드 |
| `git commit` | 게임 세이브 |
| `git branch` | A안, B안 동시 작업 |
| `git push` | Google Drive에 업로드 |

**핵심:** git = 실행 취소의 끝판왕. 뭘 해도 돌아갈 수 있다.

### 3.5 비개발자 핵심 포인트

- 명령어 외울 필요 없음 → **Claude에게 말로 시키면 됨**
- 개념만 이해하면 OK
- "최근 커밋 보여줘", "git 상태 확인해줘" 이렇게 말하면 됨

---

## 4. Vercel + Supabase 완전 가이드 (비개발자용)

### 4.1 스킬 vs 서비스의 차이

| 구분 | 스킬 | 서비스 |
|------|------|--------|
| 비유 | 내 노트북에 있는 글 초안 | 그 글을 블로그에 발행 |
| 접근성 | 나만 읽을 수 있음 | 누구나 접속 가능한 URL |
| 특징 | 로컬에서만 동작 | 데이터 저장, 검색, API 연동 |

> "스킬에 살을 붙이면 서비스가 된다"

### 4.2 3가지 인프라의 역할 (블로그 비유)

**GitHub = 작가의 작업실**
- 글의 모든 버전을 기록 (언제든 이전 버전으로)
- 공동 집필 가능 (PR = "이렇게 수정해봤는데 어때?")
- 여러 버전 동시 작업 (Branch = "A안, B안 따로 써보기")

**Vercel = 자동 발행 시스템**
- GitHub에 글을 올리면 → 자동으로 블로그에 반영
- 수정하면 → 자동으로 업데이트
- 전 세계 어디서든 접속 가능한 URL 생성

**Supabase = 독자 관리 + 데이터**
- 방문자 수, 좋아요, 댓글 저장
- 검색 기능
- API로 다른 서비스와 연동

### 4.3 서비스화 플로우

```
스킬 (나만 쓰는 것)
    ↓
"이걸 다른 사람도 쓸 수 있게 만들고 싶다"
    ↓
서비스화 = 스킬에 "살"을 붙이는 것
  • 웹 인터페이스 (Vercel)
  • 데이터 저장/조회 (Supabase)
  • 버전 관리/협업 (GitHub)
  • API로 외부 연동
    ↓
실제 서비스로 동작!
```

### 4.4 실제 사례: Skill Directory

- 시작: "스킬 목록을 정리하고 싶다"
- 결정: "다른 사람도 검색하고 찾을 수 있게 하자"
- 구성: GitHub(코드) + Vercel(웹사이트) + Supabase(스킬 DB)
- 확장: 실시간 검색, 투표/설치 추적, 트렌딩 정렬, API rate limiting
- 결과: 400개+ 스킬, 누구나 접속 가능

### 4.5 Claude에게 요청하는 명령어 예시

**Vercel 관련:**
- "이 프로젝트를 Vercel에 배포할 수 있게 설정해줘"
- "Vercel 배포용 설정 파일 만들어줘"

**Supabase 관련:**
- "Supabase에 연결해서 데이터를 저장하는 코드 만들어줘"
- "이 스킬 결과를 Supabase 테이블에 저장해줘"

**통합:**
- "GitHub에 push하면 Vercel이 자동 배포되게 연결해줘"
- "검색 기능 추가해줘"
- "API rate limiting 추가해줘"

### 4.6 비개발자 핵심 포인트

- 코드를 몰라도 됨 → Claude에게 말로 시키면 됨
- 설치는 가이드 따라하면 됨
- 확장은 필요할 때 하면 됨 (지금 당장 안 해도 OK)

---

## 5. Compound 사이클 실습 가이드

### 5.1 실습 A: CLAUDE.md 규칙 추가 (필수, 15분)

| 단계 | 활동 | 시간 |
|------|------|------|
| 1. Notice | Day 1~3 동안 매번 반복해서 말한 것 찾기 | 3분 |
| 2. Debug | "왜 매번 말해야 했을까?" → CLAUDE.md에 없었기 때문 | 2분 |
| 3. Fix | "CLAUDE.md에 다음 규칙을 추가해줘: [반복했던 것]" | 5분 |
| 4. Document | "방금 추가한 규칙이 뭔지 CLAUDE.md에서 확인해줘" | 2분 |
| 5. 효과 확인 | /clear 후 새 대화에서 규칙 적용 테스트 | 3분 |

**반복 예시:** "한국어로 답해줘", "표로 정리해줘", "존댓말로 해줘"

### 5.2 실습 B: 스킬 출력 수정 (선택, 5분)

1. Use — Day 3 스킬 실행
2. Notice — 출력 중 마음에 안 드는 부분 발견
3. Fix — "이 스킬의 출력 포맷을 [원하는 형식]으로 바꿔줘"
4. Use Again — 변화 확인

### 5.3 1주일 목표 설정

**템플릿:** "1주일 후, 나는 [________]를 보여줄 수 있다"

**작성 가이드:**
- 구체적으로: "주간 업무 요약 스킬이 Slack + Gmail 데이터를 가져온다"
- 측정 가능하게: "동작하는 영상을 녹화할 수 있다"
- 현실적으로: "한 가지 업무가 자동화된다"

---

## 6. 핵심 비유 모음

| 개념 | 비유 | 한 줄 설명 |
|------|------|----------|
| Context Engineering | 업무 매뉴얼 만들기 | AI가 참고할 맥락을 설계 |
| Compound Engineering | 복리 이자 | 조금씩 고치면 나중에 크게 돌아옴 |
| 풀 사이클 | 요리 개선 과정 | 만들고 → 먹어보고 → 부족한 점 찾고 → 레시피 수정 |
| Repository | 프로젝트의 집 | 모든 파일이 사는 곳 |
| Commit | 게임 세이브 | 잘 되는 시점에 저장 |
| Branch | 실험용 복사본 | 원본 안 건드리고 시도 |
| Pull Request | 결재 문서 | "이렇게 바꿔봤는데 봐줘" |
| git | 실행 취소의 끝판왕 | 뭘 해도 돌아갈 수 있음 |
| 스킬 vs 서비스 | 글 초안 vs 블로그 발행 | 나만 쓰는 것 vs 세상에 공개 |
| GitHub | 작가의 작업실 | 버전 관리 + 협업 |
| Vercel | 자동 발행 시스템 | GitHub에 올리면 자동으로 웹사이트로 |
| Supabase | 독자 관리 + 데이터 | 방문자, 좋아요, 검색 데이터 관리 |

---

## 7. 비개발자 FAQ

### Q: GitHub이 꼭 필요한가요?
지금 당장은 아니지만, Compound Engineering을 계속하려면 필요합니다. 변경 이력을 기록하고 되돌릴 수 있는 시스템이 없으면, 복리 효과를 얻기 어렵습니다. Claude에게 말로 시키면 되니까 명령어를 외울 필요는 없습니다.

### Q: git 명령어를 외워야 하나요?
아니요! Claude에게 "최근 커밋 보여줘", "git 상태 확인해줘"라고 말하면 됩니다. 개념만 이해하고, 실행은 Claude에게 맡기세요.

### Q: CLAUDE.md 규칙을 너무 많이 추가하면 어떻게 되나요?
너무 길면 오히려 효과가 줄어들 수 있습니다. 핵심 규칙만 간결하게 유지하세요. 나중에 안 쓰는 규칙은 정리하면 됩니다.

### Q: Compound Engineering을 혼자서도 할 수 있나요?
네! 쓰면서 불편한 점 발견 → 규칙 추가 → 다시 써보는 사이클을 혼자서 반복하면 됩니다. 팀이 없어도 가능합니다.

### Q: 최종 발표 때 완벽한 결과물이 없으면 어떡하나요?
완벽하지 않아도 괜찮습니다. 중요한 건 '실제로 동작하는 것'입니다. 작은 기능이라도 실제로 돌아가는 것을 보여주세요. 과정에서 배운 것도 충분히 가치 있습니다.

### Q: Vercel이나 Supabase는 지금 당장 써야 하나요?
아닙니다. 스킬을 서비스로 확장하고 싶을 때 쓰면 됩니다. 우선은 CLAUDE.md와 스킬을 잘 만드는 것에 집중하세요.
