# Day 4: 시스템화 — 만든 걸 복리로 키우는 법

## 1. Day 4 개요

| 항목 | 내용 |
|------|------|
| 테마 | 시스템화 (Systematization) — "만든 걸 복리로 키우는 법" |
| 핵심 메시지 | **한 번 만들고 끝이 아니다. 쓰면서 고치면 복리로 성장한다.** |
| 총 소요 시간 | 약 165분 (2시간 45분, 휴식 포함) |
| 사전 과제 | Day 3 스킬 제작 완료 (또는 시도) |
| 산출물 | 개선된 CLAUDE.md + 1주 목표 설정 |

### 학습 목표

1. Context Engineering의 의미를 이해하고, Day 1~3이 이미 Context Engineering이었음을 인식한다
2. Compound Engineering 풀 사이클(Build → Use → Notice → Debug → Fix → Document)을 이해한다
3. GitHub의 핵심 개념 4가지(Repository, Commit, Branch, Pull Request)를 비유로 이해한다
4. Vercel과 Supabase의 역할을 이해하고, 스킬을 서비스로 확장하는 방법을 안다
5. CLAUDE.md에 규칙을 추가하는 Compound 사이클을 직접 체험한다
6. 1주 후 최종 발표를 위한 목표를 설정한다

### 시간 배분

| 섹션 | 시간 | 내용 |
|------|------|------|
| 섹션 1 | 10분 | Day 1-3 리캡 |
| 섹션 2 | 25분 | Context Engineering |
| 섹션 3 | 30분 | Compound Engineering |
| 섹션 4 | 20분 | GitHub 기초 |
| 섹션 5 | 15분 | Vercel + Supabase: 스킬을 서비스로 |
| 휴식 | 10분 | - |
| 섹션 6 | 20분 | Compound 사이클 실습 |
| 섹션 7 | 25분 | 문제와 목표 공유 |
| 섹션 8 | 10분 | 후속 여정 안내 + 마무리 |

---

## 2. 슬라이드 구성

### 섹션 1: Day 1-3 리캡 (10분)

#### 슬라이드 1-1: 타이틀
```
Day 4
만든 걸 복리로 키우는 법

Context Engineering + Compound Engineering

AI Native Camp
[날짜]
```

#### 슬라이드 1-2: 4일의 여정 + 산출물
```
4일의 여정

Day 1    CLAUDE.md          내 맥락을 설계
Day 2    MCP 연결           외부 도구의 맥락을 연결
Day 3    스킬               맥락 기반 워크플로우
Day 4    쓰고 → 고치고 → 쌓는다   (오늘)

         ↓ 1주일 후 ↓
         
최종 발표  "내 일이 이렇게 바뀌었다"
```

---

### 섹션 2: Context Engineering (25분)

#### 슬라이드 2-1: 섹션 타이틀
```
Context Engineering

"프롬프트 잘 쓰는 법을 배운 게 아닙니다.
 AI가 참고할 맥락 전체를 설계한 겁니다."
```

#### 슬라이드 2-2: 이 캠프가 처음부터 Context Engineering이었다
```
이 캠프가 처음부터 Context Engineering이었다

┌─────────────┐   ┌─────────────┐   ┌─────────────┐
│   Day 1     │   │   Day 2     │   │   Day 3     │
│             │   │             │   │             │
│ CLAUDE.md = │   │ MCP 연결 =  │   │  스킬 =     │
│ 내 맥락을   │   │ 외부 도구의 │   │ 맥락 기반   │
│ 설계        │   │ 맥락을 연결 │   │ 워크플로우  │
│             │   │             │   │             │
│ Context     │   │ Context     │   │ Context     │
│ 설계        │   │ 확장        │   │ 활용        │
└─────────────┘   └─────────────┘   └─────────────┘

"프롬프트 잘 쓰는 법을 배운 게 아닙니다.
 AI가 참고할 맥락 전체를 설계한 겁니다. 이미 하고 있었어요."
```

#### 슬라이드 2-3: 왜 이 말이 뜨게 됐는가
```
Prompt Engineering → Context Engineering

2023    "프롬프트를 잘 쓰면 된다"
        Prompt Engineering
        
2024    "프롬프트 + 맥락을 잘 구성하면 된다"
        RAG, Few-shot
        
2025~   "맥락 자체를 설계하고 관리해야 한다"
        Context Engineering

───────────────────────────────────────────────
AI 모델 = 순수 함수 (Pure Function)
출력의 품질을 결정하는 건 오직 입력의 품질

Garbage In, Garbage Out
입력 품질 = 출력 품질
```

#### 슬라이드 2-4: 업계가 발견한 세 가지 교훈
```
업계가 발견한 세 가지 교훈

01  프롬프트가 아니라 데이터가 문제
    CLAUDE.md가 부정확하면 AI 결과도 부정확
    
02  계획 리뷰가 결과 리뷰보다 효율적
    2,000줄 결과물보다 200줄 계획을 리뷰하는 게 낫다
    
03  한번 설계하면 매번 효과
    맥락을 한번 잘 설계하면 "대충 물어봐도" AI가 잘 답한다

───────────────────────────────────────────────
LangChain 2025 (1,340명 조사):
품질 문제의 32%가 AI 능력 부족이 아니라 "맥락 관리 실패"
```

#### 슬라이드 2-5: 지식의 저주
```
지식의 저주 — 왜 맥락 전달이 어려운가

Stanford Newton 실험 (1990)
120곡을 손가락으로 두드려서 상대방한테 맞히게 함

두드리는 사람 예측: 50%
실제 정답률: 2.5%
→ 20배 과대평가

───────────────────────────────────────────────
MIT Sloan 연구
"전문가는 자기 도메인에서 비전문가보다 더 나쁜 커뮤니케이터"

IDC 조사
직원 전문 스킬의 42%는 본인만 알고 있음
F500 연간 지식 공유 실패 비용: $31.5B
```

#### 슬라이드 2-6: 역할의 변화
```
타이피스트에서 매니저로

과거                          지금
─────────────────────────────────────────────
직접 타이핑하는 사람          AI를 관리하는 사람

내가 직접 문서 쓰고           계획을 세워주고
직접 분석하고                 결과물을 검토하고
직접 코드 짬                  피드백하고 승인

───────────────────────────────────────────────
Context Engineering = AI가 참고할 맥락을 설계하는 것 (설계)
Compound Engineering = 그 맥락을 쓰면서 계속 개선하는 것 (반복)

"설계만 하고 안 고치면 낡아갑니다. 고치는 과정이 복리입니다."
```

---

### 섹션 3: Compound Engineering (30분)

#### 슬라이드 3-1: 섹션 타이틀
```
Compound Engineering

"한 번 만들고 끝이 아니라,
 쓰면서 고치면 복리로 성장한다"
```

#### 슬라이드 3-2: 기존 방식 vs Compound 방식
```
기존 방식 vs Compound 방식

기존 방식
─────────────────────────────────────────────
AI에게 일 시킴 → AI가 실수 → 채팅으로 고쳐달라고 함
→ 다음에 또 같은 실수 반복 😤

Compound 방식
─────────────────────────────────────────────
AI가 실수 → "왜 실수했어?" 원인 파악
→ CLAUDE.md에 규칙 추가
→ 다음부터는 그 실수 안 함 ✅
→ 나만의 완벽한 파트너!

───────────────────────────────────────────────
기존: "잘 만들어서 → 완성하면 → 끝" ✕
우리: "일단 만들고 → 쓰면서 → 계속 고치면 → 복리" ✓
```

#### 슬라이드 3-3: 풀 사이클 6단계
```
풀 사이클 — 어떻게 돌리는가

┌─────────┐   ┌─────────┐   ┌─────────┐
│  Build  │ → │   Use   │ → │ Notice  │
│ 일단    │   │ 실제로  │   │ 불편함  │
│ 만든다  │   │ 써본다  │   │ 발견    │
└─────────┘   └─────────┘   └─────────┘
                               ↓
┌─────────┐   ┌─────────┐   ┌─────────┐
│Document │ ← │   Fix   │ ← │  Debug  │
│ 기록    │   │ 한 가지 │   │ 원인을  │
│ 한다    │   │ 만 고침 │   │ 찾는다  │
└─────────┘   └─────────┘   └─────────┘

"한번에 100% 만드는 게 아니라, 1%씩 100번 개선하는 것.
 이게 복리입니다."
```

#### 슬라이드 3-4: 구체적 이득 3가지
```
구체적 이득 3가지

01  같은 말을 반복하지 않아도 된다
    "한국어로 답해줘" 매번 말하는 건 비효율
    CLAUDE.md에 한번 적으면 영원히 적용

02  혼자서도 팀만큼의 결과를 낸다
    약한 모델 + 좋은 워크플로우 (95.1%)
    > 강한 모델 단독 (67.0%)
    BCG 연구: 품질 +40%

03  미래 핵심 역량이 된다
    Microsoft 2025: 글로벌 리더 82%가 
    AI 에이전트를 팀원으로 도입 예정

───────────────────────────────────────────────
Day 1: "AI를 잘 쓰는 건 단계"
Day 4: 그 단계를 반복하는 사이클이 Compound Engineering
```

#### 슬라이드 3-5: 문서화가 성과를 만든다
```
문서화가 성과를 만든다

Google DORA 2023 연구
───────────────────────────────────────────────
질 높은 내부 문서화 → 조직 성과에 12.8배 영향

AI 시대의 문서화
───────────────────────────────────────────────
AI는 코드보다 문서화 품질을 가장 크게 개선 (+7.5%)

               CLAUDE.md
               스킬 설명
               MCP 설정
                  ↓
            다 "문서"입니다
```

#### 슬라이드 3-6: 오늘의 핵심 3줄
```
오늘 핵심 3줄

1️⃣ 만든 것의 가치는 완성도가 아니라 반복 횟수에 있다
   (복리)

2️⃣ 불편함은 버그가 아니라 개선의 신호다
   (풀 사이클)

3️⃣ 사이클을 한 바퀴 돌린 사람은 
   이미 Compound Engineering을 하고 있다
```

---

### 섹션 4: GitHub 기초 (20분)

#### 슬라이드 4-1: 섹션 타이틀
```
GitHub 기초

"기록 없이는 복리가 안 된다"
```

#### 슬라이드 4-2: GitHub = 복리의 인프라
```
GitHub = 복리의 인프라

만든다 → 쓴다 → 고친다 → 기록한다
                         ↑ GitHub이 하는 일

고칠 때마다 commit → 변경 이력이 자동으로 쌓인다
"3일 전 버전이 더 나았네" → 되돌릴 수 있다

───────────────────────────────────────────────
기록 없이는 복리가 안 된다
```

#### 슬라이드 4-3: 핵심 기능 4가지
```
GitHub 핵심 기능 4가지

┌─────────────────────────────────────────────────────┐
│  Repository              "내 프로젝트의 집"          │
│                          CLAUDE.md, 스킬, MCP 설정이 │
│                          사는 곳                     │
├─────────────────────────────────────────────────────┤
│  Commit                  "게임 세이브 포인트"        │
│                          잘 되는 시점에 저장 +       │
│                          왜 바꿨는지 메모            │
├─────────────────────────────────────────────────────┤
│  Branch                  "원본 안 건드리고           │
│                           실험하는 복사본"           │
│                          원본(main)은 항상 안전      │
├─────────────────────────────────────────────────────┤
│  Pull Request            "이렇게 바꿔봤는데 봐줘"    │
│                          합치기 전 검토 요청         │
└─────────────────────────────────────────────────────┘
```

#### 슬라이드 4-4: git 명령어 비유
```
git 명령어 비유

┌──────────┬──────────────────────────────────────┐
│ 명령어   │ 비유                                 │
├──────────┼──────────────────────────────────────┤
│ git clone│ Google Drive에서 폴더 다운로드       │
│ git commit│ 게임 세이브                         │
│ git branch│ A안, B안 동시 작업                  │
│ git push │ Google Drive에 업로드                │
└──────────┴──────────────────────────────────────┘

git = 실행 취소의 끝판왕
뭘 해도 돌아갈 수 있다

───────────────────────────────────────────────
💡 명령어를 외울 필요 없습니다
   Claude에게 말로 시키면 됩니다
```

---

### 섹션 5: Vercel + Supabase — 스킬을 서비스로 (15분)

#### 슬라이드 5-1: 섹션 타이틀
```
스킬을 서비스로

"나만 쓰는 것 → 세상이 쓰는 것"
```

#### 슬라이드 5-2: 스킬 vs 서비스
```
스킬 vs 서비스

스킬
───────────────────────────────────────────────
내 노트북에 있는 글 초안
나만 읽을 수 있음

서비스
───────────────────────────────────────────────
그 글을 블로그에 발행해서 세상에 공개
누구나 접속 가능한 URL
데이터 저장, 검색, API 연동

───────────────────────────────────────────────
"스킬에 살을 붙이면 서비스가 된다"
```

#### 슬라이드 5-3: 3가지 인프라의 역할
```
3가지 인프라의 역할

GitHub = 작가의 작업실
───────────────────────────────────────────────
• 글의 모든 버전을 기록 (언제든 이전 버전으로)
• 공동 집필 가능 (PR = "이렇게 수정해봤는데 어때?")
• 여러 버전 동시 작업 (Branch = "A안, B안 따로 써보기")

Vercel = 자동 발행 시스템
───────────────────────────────────────────────
• GitHub에 글을 올리면 → 자동으로 블로그에 반영
• 수정하면 → 자동으로 업데이트
• 전 세계 어디서든 접속 가능한 URL 생성

Supabase = 독자 관리 + 데이터
───────────────────────────────────────────────
• 방문자 수, 좋아요, 댓글 저장
• 검색 기능
• API로 다른 서비스와 연동
```

#### 슬라이드 5-4: 서비스화 플로우
```
스킬 → 서비스 플로우

스킬 (나만 쓰는 것)
    ↓
"이걸 다른 사람도 쓸 수 있게 만들고 싶다"
    ↓
┌─────────────────────────────────────────┐
│  서비스화 = 스킬에 "살"을 붙이는 것      │
│                                         │
│  • 웹 인터페이스 (Vercel)               │
│  • 데이터 저장/조회 (Supabase)          │
│  • 버전 관리/협업 (GitHub)              │
│  • API로 외부 연동                      │
└─────────────────────────────────────────┘
    ↓
실제 서비스로 동작!
```

#### 슬라이드 5-5: 실제 사례 — Skill Directory
```
실제 사례: Skill Directory

🔗 skill-directory-livid.vercel.app

시작: "스킬 목록을 정리하고 싶다"
    ↓
결정: "다른 사람도 검색하고 찾을 수 있게 하자"
    ↓
구성:
• GitHub: 코드 저장 + 버전 관리
• Vercel: 웹사이트 배포
• Supabase: 스킬 DB + API
    ↓
확장 (Claude에게 시키면서):
• 실시간 검색, 투표/설치 추적
• 트렌딩/인기 정렬, API rate limiting
• 이메일 알림, 주간 자동 업데이트
    ↓
결과: 400개+ 스킬, 누구나 접속 가능
```

#### 슬라이드 5-6: Claude에게 요청하는 명령어 예시
```
Claude에게 이렇게 시키면 됩니다

Vercel 관련:
───────────────────────────────────────────────
"이 프로젝트를 Vercel에 배포할 수 있게 설정해줘"
"Vercel 배포용 설정 파일 만들어줘"

Supabase 관련:
───────────────────────────────────────────────
"Supabase에 연결해서 데이터를 저장하는 코드 만들어줘"
"이 스킬 결과를 Supabase 테이블에 저장해줘"

통합:
───────────────────────────────────────────────
"GitHub에 push하면 Vercel이 자동 배포되게 연결해줘"
"검색 기능 추가해줘"
"API rate limiting 추가해줘"

💡 코드를 몰라도 됩니다. 말로 시키면 Claude가 만들어줍니다.
```

---

### 휴식 (10분)

```
☕ 10분 휴식

다음 시간:
Compound Engineering 사이클 직접 체험하기
```

---

### 섹션 6: Compound 사이클 실습 (20분)

#### 슬라이드 6-1: 섹션 타이틀
```
Compound 사이클 실습

"오늘 여러분이 할 일은 딱 하나입니다.
 사이클을 한 바퀴 돌리는 것."
```

#### 슬라이드 6-2: 실습 A — CLAUDE.md 규칙 추가 (필수)
```
실습 A: CLAUDE.md에 규칙 추가하기 (15분)

1️⃣ Notice (불편함 발견) — 3분
   "Day 1~3 동안 Claude에게 매번 반복해서 말한 것이 있었나요?"
   예: "한국어로 답해줘", "표로 정리해줘", "존댓말로 해줘"

2️⃣ Debug (원인 파악) — 2분
   "왜 매번 말해야 했을까요?"
   → CLAUDE.md에 없었기 때문

3️⃣ Fix (규칙 추가) — 5분
   Claude Code에서:
   "CLAUDE.md에 다음 규칙을 추가해줘: [본인이 반복했던 것]"

4️⃣ Document (기록) — 2분
   "방금 추가한 규칙이 뭔지 CLAUDE.md에서 확인해줘"

5️⃣ 효과 확인 — 3분
   새 대화에서 규칙이 적용되는지 테스트
```

#### 슬라이드 6-3: 실습 B — 스킬 한 줄 수정 (선택)
```
실습 B: 스킬 출력 형식 수정하기 (선택, 5분)

Day 3에서 만든 스킬이 있다면:

1️⃣ Use (써보기)
   스킬 실행

2️⃣ Notice (불편함 발견)
   "출력 결과 중 마음에 안 드는 부분이 있나요?"
   예: "너무 길다", "표로 보고 싶다"

3️⃣ Fix (한 줄 수정)
   "이 스킬의 출력 포맷을 [원하는 형식]으로 바꿔줘"

4️⃣ Use Again (다시 실행)
   변화 확인

───────────────────────────────────────────────
💡 Day 3 스킬이 없어도 괜찮습니다
   실습 A만 해도 충분합니다
```

#### 슬라이드 6-4: 실습 완료 확인
```
실습 완료 체크

☐ CLAUDE.md에 새 규칙이 추가되었다
☐ 새 대화에서 규칙이 적용되는지 확인했다

(선택)
☐ Day 3 스킬의 출력 형식을 수정했다
☐ 수정된 결과를 확인했다

───────────────────────────────────────────────
🎉 축하합니다!
   사이클을 한 바퀴 돌렸습니다.
   여러분은 이미 Compound Engineering을 하고 있습니다.
```

---

### 섹션 7: 문제와 목표 공유 (25분)

#### 슬라이드 7-1: 섹션 타이틀
```
문제와 목표 공유

"서로의 경험에서 배우기"
```

#### 슬라이드 7-2: 공유 가이드
```
공유 가이드 (1인 3분)

1️⃣ 내가 해결하려는 문제
   "저는 [이런 문제]를 해결하고 싶었습니다"

2️⃣ 지금까지 만든 것
   "Day 1~3 동안 [이런 것]을 만들었습니다"
   CLAUDE.md, MCP 연결, 스킬 등

3️⃣ 겪은 어려움 또는 발견
   "이 과정에서 [이런 점]이 어려웠습니다 / 발견했습니다"

4️⃣ 1주일 후 목표
   "최종 발표 때 [이런 결과]를 보여드리고 싶습니다"
```

#### 슬라이드 7-3: 피드백 가이드
```
피드백 가이드

들으면서 생각해볼 것:

💡 "나도 비슷한 문제가 있었는데..."
   → 공감 표현하기

💡 "저는 이렇게 해봤는데요..."
   → 경험 공유하기

💡 "혹시 [이 방법]은 시도해보셨나요?"
   → 아이디어 제안하기

───────────────────────────────────────────────
❌ 피하기: "그건 안 될 것 같아요"
✅ 좋은 예: "저도 비슷한 시도를 했는데, 이런 점이 도움됐어요"
```

#### 슬라이드 7-4: 1주일 목표 설정
```
1주일 목표 설정

최종 발표까지 1주일!

목표 설정 템플릿:
───────────────────────────────────────────────
"1주일 후, 나는 [                ]를 
 보여줄 수 있다"

예시:
• "실제로 동작하는 스킬 영상을 보여줄 수 있다"
• "주간 업무 자동화 스킬이 내 워크플로우에서 작동한다"
• "CLAUDE.md가 내 업무 맥락을 완벽히 반영한다"

───────────────────────────────────────────────
💡 제출물: 동작하는 영상 또는 링크
```

---

### 섹션 8: 후속 여정 안내 + 마무리 (10분)

#### 슬라이드 8-1: 섹션 타이틀
```
다음 주, 최종 발표에서 만나요

"오늘 집중 교육은 끝.
 하지만 진짜 마무리는 다음 주입니다."
```

#### 슬라이드 8-2: 1주 후 최종 발표
```
1주 후 최종 발표

📅 일시: [날짜] (별도 공지)

📋 발표 내용:
   • 해결하려는 문제
   • 만든 것 (스킬, CLAUDE.md 등)
   • 실제 동작 시연
   • 배운 점과 다음 계획

📎 제출물:
   • 동작하는 영상 또는 링크
   • (상세 가이드는 별도 공지)
```

#### 슬라이드 8-3: 1주일 동안 할 일
```
1주일 동안 할 일

1️⃣ 만든 것 실제로 써보기
   CLAUDE.md, 스킬을 실제 업무에 적용

2️⃣ 불편한 점 발견하면 고치기
   Compound Engineering 사이클 반복

3️⃣ 최종 발표 준비
   동작하는 영상 또는 링크 준비

───────────────────────────────────────────────
💡 기억하세요:
   "완벽하게 만들고 끝"이 아니라
   "쓰면서 계속 고치기"
```

#### 슬라이드 8-4: 오늘 배운 것
```
오늘 배운 것

✅ Context Engineering
   "프롬프트가 아니라 맥락을 설계하는 것"

✅ Compound Engineering
   "쓰면서 고치면 복리로 성장"

✅ GitHub 기초
   "기록 없이는 복리가 안 된다"

✅ Vercel + Supabase
   "스킬을 서비스로 확장하는 인프라"

✅ 사이클 체험
   "CLAUDE.md에 규칙 추가해봤다"

───────────────────────────────────────────────
가져가는 것: 개선된 CLAUDE.md + 1주 목표
```

#### 슬라이드 8-5: 마무리
```
Day 4 마무리

"4일 동안 세 가지를 만들었습니다.
 CLAUDE.md, MCP 연결, 스킬.

 오늘 배운 건 이것들을 
 내 마음에 들게 만드는 법입니다.

 쓰고, 고치고, 쌓으세요.
 그게 복리입니다."

───────────────────────────────────────────────
다음 주 최종 발표에서
여러분의 결과물을 기대하겠습니다! 🎉
```

---

## 3. 핵심 개념 상세 정리

### 3.1 Context Engineering 완전 가이드

```
[Context Engineering 완전 가이드]

1. 정의
   AI가 참고할 맥락 전체를 설계하고 관리하는 기술
   (Prompt Engineering의 확장 개념)

2. 진화 과정
   2023: Prompt Engineering — 프롬프트를 잘 쓰면 된다
   2024: RAG, Few-shot — 프롬프트 + 맥락 구성
   2025: Context Engineering — 맥락 자체를 설계/관리

3. AI Native Camp에서의 적용
   Day 1: CLAUDE.md = Context 설계
   Day 2: MCP 연결 = Context 확장
   Day 3: 스킬 = Context 활용

4. 핵심 교훈 3가지
   ① 프롬프트가 아니라 데이터가 문제
   ② 계획 리뷰 > 결과 리뷰
   ③ 한번 설계하면 매번 효과

5. 왜 중요한가
   - LangChain 조사: 품질 문제의 32%가 맥락 관리 실패
   - 지식의 저주: 내가 아는 것을 AI도 안다고 착각
   - 명시적 맥락 전달 필요
```

### 3.2 Compound Engineering 완전 가이드

```
[Compound Engineering 완전 가이드]

1. 정의
   AI에게 일을 시킬 때마다 AI를 더 똑똑하게 만들어
   업무 효율을 복리(Compound Interest)처럼 불리는 방법

2. 핵심 철학
   "잘 만들어서 → 완성하면 → 끝" ✕
   "일단 만들고 → 쓰면서 → 계속 고치면 → 복리" ✓

3. 풀 사이클 6단계
   ┌─────────────────────────────────────────────────┐
   │ Build    → 일단 만든다                          │
   │ Use      → 실제로 써본다                        │
   │ Notice   → 불편함을 발견한다                    │
   │ Debug    → 원인을 찾는다                        │
   │ Fix      → 한 가지만 고친다                     │
   │ Document → 기록한다                             │
   └─────────────────────────────────────────────────┘

4. 구체적 이득
   ① 같은 말 반복 안 함 (CLAUDE.md에 규칙 추가)
   ② 혼자서도 팀만큼 결과 (워크플로우 > 모델)
   ③ 미래 핵심 역량 (82% 리더가 AI 에이전트 도입 예정)

5. Context vs Compound
   Context Engineering = 맥락을 설계하는 것 (설계)
   Compound Engineering = 맥락을 쓰면서 개선하는 것 (반복)
```

### 3.3 GitHub 완전 가이드 (비개발자용)

```
[GitHub 완전 가이드 — 비개발자용]

1. GitHub이란?
   - 저장 + 공유 + 변경 이력 + 협업 리뷰
   - Google Drive의 "변경 이력 + 협업" 강화 버전
   - 2025년 기준 1.8억 명 사용

2. 왜 필요한가?
   - CLAUDE.md, 스킬, MCP 설정도 한 줄 바꾸면 결과가 달라짐
   - 모든 변경을 기록하고, 되돌릴 수 있어야 함
   - "기록 없이는 복리가 안 된다"

3. 핵심 기능 4가지
   ┌─────────────┬──────────────────────────────────┐
   │ Repository  │ "내 프로젝트의 집"                │
   │ Commit      │ "게임 세이브 포인트"              │
   │ Branch      │ "원본 안 건드리고 실험하는 복사본"│
   │ Pull Request│ "이렇게 바꿔봤는데 봐줘"          │
   └─────────────┴──────────────────────────────────┘

4. git 명령어 비유
   ┌──────────┬──────────────────────────────────────┐
   │ git clone│ Google Drive에서 폴더 다운로드       │
   │ git commit│ 게임 세이브                         │
   │ git branch│ A안, B안 동시 작업                  │
   │ git push │ Google Drive에 업로드                │
   └──────────┴──────────────────────────────────────┘

5. 비개발자 핵심 포인트
   - 명령어 외울 필요 없음 → Claude에게 말로 시키면 됨
   - 개념만 이해하면 OK
   - git = 실행 취소의 끝판왕
```

### 3.4 Vercel + Supabase 완전 가이드 (비개발자용)

```
[Vercel + Supabase 완전 가이드 — 비개발자용]

1. 스킬 vs 서비스의 차이
   ┌─────────────────────────────────────────────────┐
   │ 스킬         = 내 노트북에 있는 글 초안          │
   │               (나만 읽을 수 있음)                │
   │                                                 │
   │ 서비스       = 그 글을 블로그에 발행             │
   │               (누구나 접속 가능)                 │
   └─────────────────────────────────────────────────┘

2. 3가지 인프라의 역할 (블로그 비유)
   
   GitHub = 작가의 작업실
   ───────────────────────────────────────────────
   • 글의 모든 버전을 기록 (언제든 이전 버전으로)
   • 공동 집필 가능 (PR = "이렇게 수정해봤는데 어때?")
   • 여러 버전 동시 작업 (Branch = "A안, B안 따로 써보기")
   
   Vercel = 자동 발행 시스템
   ───────────────────────────────────────────────
   • GitHub에 글을 올리면 → 자동으로 블로그에 반영
   • 수정하면 → 자동으로 업데이트
   • 전 세계 어디서든 접속 가능한 URL 생성
   
   Supabase = 독자 관리 + 데이터
   ───────────────────────────────────────────────
   • 방문자 수, 좋아요, 댓글 저장
   • 검색 기능
   • API로 다른 서비스와 연동

3. 서비스화 플로우
   스킬 (나만 쓰는 것)
       ↓
   "이걸 다른 사람도 쓸 수 있게 만들고 싶다"
       ↓
   ┌─────────────────────────────────────────┐
   │  서비스화 = 스킬에 "살"을 붙이는 것      │
   │                                         │
   │  • 웹 인터페이스 (Vercel)               │
   │  • 데이터 저장/조회 (Supabase)          │
   │  • 버전 관리/협업 (GitHub)              │
   │  • API로 외부 연동                      │
   └─────────────────────────────────────────┘
       ↓
   실제 서비스로 동작!

4. Claude에게 요청하는 명령어 예시
   
   Vercel 관련:
   - "이 프로젝트를 Vercel에 배포할 수 있게 설정해줘"
   - "Vercel 배포용 설정 파일 만들어줘"
   
   Supabase 관련:
   - "Supabase에 연결해서 데이터를 저장하는 코드 만들어줘"
   - "이 스킬 결과를 Supabase 테이블에 저장해줘"
   
   통합:
   - "GitHub에 push하면 Vercel이 자동 배포되게 연결해줘"
   - "검색 기능 추가해줘"
   - "API rate limiting 추가해줘"

5. 비개발자 핵심 포인트
   - 코드를 몰라도 됨 → Claude에게 말로 시키면 됨
   - 설치는 가이드 따라하면 됨
   - 확장은 필요할 때 하면 됨 (지금 당장 안 해도 OK)
```

---

## 4. 실습 가이드

### 실습 1: CLAUDE.md 규칙 추가 (Compound 사이클)

```
[실습 1: CLAUDE.md 규칙 추가]

목표: Compound Engineering 사이클 한 바퀴 돌리기

단계:
1. Notice (불편함 발견) — 3분
   Day 1~3 동안 Claude에게 매번 반복해서 말한 것이 있었나요?
   
   예시:
   - "한국어로 답해줘"
   - "표로 정리해줘"
   - "존댓말로 해줘"
   - "코드에 주석 달아줘"

2. Debug (원인 파악) — 2분
   왜 매번 말해야 했을까요?
   → CLAUDE.md에 해당 규칙이 없었기 때문

3. Fix (규칙 추가) — 5분
   Claude Code에서:
   "CLAUDE.md에 다음 규칙을 추가해줘: [본인이 반복했던 것]"
   
   예시:
   "CLAUDE.md에 다음 규칙을 추가해줘:
    - 항상 한국어로 답변할 것
    - 긴 내용은 표로 정리할 것"

4. Document (기록) — 2분
   "방금 추가한 규칙이 뭔지 CLAUDE.md에서 확인해줘"

5. 효과 확인 — 3분
   /clear로 새 대화 시작 후:
   "아무 질문이나 해서 규칙이 적용되는지 확인"

확인:
- CLAUDE.md에 새 규칙이 추가되었는가?
- 새 대화에서 규칙이 적용되는가?

💡 축하합니다! 사이클을 한 바퀴 돌렸습니다.
```

### 실습 2: 스킬 출력 수정 (선택)

```
[실습 2: 스킬 출력 수정 — 선택]

목표: Day 3 스킬의 출력 형식 개선하기

전제: Day 3에서 만든 스킬이 있는 경우

단계:
1. Use (써보기) — 2분
   Day 3 스킬 실행

2. Notice (불편함 발견) — 1분
   출력 결과 중 마음에 안 드는 부분?
   예: "너무 길다", "표로 보고 싶다", "이모지가 없다"

3. Fix (수정 요청) — 2분
   "이 스킬의 출력 포맷을 [원하는 형식]으로 바꿔줘"
   
   예시:
   "이 스킬의 출력을 마크다운 표로 바꿔줘"
   "이 스킬의 출력을 3줄 요약으로 바꿔줘"

4. Use Again (재실행) — 2분
   수정된 스킬 다시 실행
   변화 확인

💡 Day 3 스킬이 없어도 괜찮습니다. 실습 1만 해도 충분합니다.
```

### 실습 3: 1주일 목표 설정

```
[실습 3: 1주일 목표 설정]

목표: 최종 발표를 위한 구체적 목표 설정

템플릿:
"1주일 후, 나는 [                ]를 보여줄 수 있다"

작성 가이드:
1. 구체적으로 (Specific)
   ✕ "스킬을 개선한다"
   ✓ "주간 업무 요약 스킬이 Slack + Gmail 데이터를 가져온다"

2. 측정 가능하게 (Measurable)
   ✕ "잘 작동하게 한다"
   ✓ "동작하는 영상을 녹화할 수 있다"

3. 현실적으로 (Realistic)
   ✕ "완벽한 자동화 시스템"
   ✓ "한 가지 업무가 자동화된다"

예시:
• "실제로 동작하는 스킬 영상을 보여줄 수 있다"
• "주간 업무 자동화 스킬이 내 워크플로우에서 작동한다"
• "CLAUDE.md가 내 업무 맥락을 완벽히 반영한다"
• "Day 3 스킬이 MCP로 Slack 데이터를 가져온다"

제출물: 동작하는 영상 또는 링크
```

---

## 5. 체크리스트

### Day 4 완료 체크리스트

```
[Day 4 완료 체크리스트]

Context Engineering:
☐ "이 캠프가 처음부터 Context Engineering이었다" 이해
☐ 업계 교훈 3가지 이해 (데이터, 계획 리뷰, 한번 설계)
☐ 역할 변화 이해 (타이피스트 → 매니저)

Compound Engineering:
☐ 기존 방식 vs Compound 방식 차이 이해
☐ 풀 사이클 6단계 이해 (Build → Use → Notice → Debug → Fix → Document)
☐ 구체적 이득 3가지 이해

GitHub 기초:
☐ 핵심 기능 4가지 이해 (Repository, Commit, Branch, PR)
☐ git 명령어 비유 이해

Vercel + Supabase:
☐ 스킬 vs 서비스 차이 이해
☐ 3가지 인프라 역할 이해 (GitHub, Vercel, Supabase)
☐ 서비스화 플로우 이해
☐ Claude에게 요청하는 명령어 예시 확인

Compound 사이클 실습:
☐ CLAUDE.md에 규칙 추가 완료 (필수)
☐ 새 대화에서 규칙 적용 확인
☐ (선택) Day 3 스킬 출력 형식 수정

문제와 목표 공유:
☐ 동료들과 경험 공유
☐ 1주일 목표 설정 완료

산출물:
☐ 개선된 CLAUDE.md
☐ 1주일 목표 (작성 완료)
```

---

## 6. 발표자용 타임라인

| 시작 | 종료 | 섹션 | 내용 | 비고 |
|------|------|------|------|------|
| 0:00 | 0:10 | 섹션 1 | Day 1-3 리캡 | 4일 여정 빠르게 훑기 |
| 0:10 | 0:35 | 섹션 2 | Context Engineering | 개념 중심 |
| 0:35 | 1:05 | 섹션 3 | Compound Engineering | 풀 사이클 + 이득 3가지 |
| 1:05 | 1:25 | 섹션 4 | GitHub 기초 | 개념 중심 |
| 1:25 | 1:40 | 섹션 5 | Vercel + Supabase | 스킬 서비스화 + 라이브 데모 |
| 1:40 | 1:50 | - | 휴식 | 10분 |
| 1:50 | 2:10 | 섹션 6 | Compound 사이클 실습 | CLAUDE.md 규칙 추가 |
| 2:10 | 2:35 | 섹션 7 | 문제와 목표 공유 | 1인 3분 공유 |
| 2:35 | 2:45 | 섹션 8 | 후속 여정 안내 + 마무리 | 1주 후 최종 발표 안내 |

---

## 7. 비개발자 FAQ

### Q: GitHub이 꼭 필요한가요?

"지금 당장은 아니지만, Compound Engineering을 계속하려면 필요합니다. 변경 이력을 기록하고 되돌릴 수 있는 시스템이 없으면, 복리 효과를 얻기 어렵습니다. Claude에게 말로 시키면 되니까 명령어를 외울 필요는 없습니다."

### Q: git 명령어를 외워야 하나요?

"아니요! Claude에게 '최근 커밋 보여줘', 'git 상태 확인해줘'라고 말하면 됩니다. 개념만 이해하고, 실행은 Claude에게 맡기세요."

### Q: CLAUDE.md 규칙을 너무 많이 추가하면 어떻게 되나요?

"너무 길면 오히려 효과가 줄어들 수 있습니다. 핵심 규칙만 간결하게 유지하세요. 나중에 안 쓰는 규칙은 정리하면 됩니다."

### Q: Compound Engineering을 혼자서도 할 수 있나요?

"네! 오늘 실습한 것처럼, 쓰면서 불편한 점 발견하고 → 규칙 추가하고 → 다시 써보는 사이클을 혼자서 반복하면 됩니다. 팀이 없어도 가능합니다."

### Q: 최종 발표 때 완벽한 결과물이 없으면 어떡하나요?

"완벽하지 않아도 괜찮습니다. 중요한 건 '실제로 동작하는 것'입니다. 작은 기능이라도 실제로 돌아가는 것을 보여주세요. 과정에서 배운 것도 충분히 가치 있습니다."

---

## 8. 참고 자료

### 공식 문서
- Claude Code CLI: https://code.claude.com/docs/ko/cli-usage
- Claude Code Skills: https://code.claude.com/docs/ko/skills
- Claude Code Memory: https://code.claude.com/docs/ko/memory

### git/GitHub 학습
- git 간편 안내서: https://rogerdudler.github.io/git-guide/index.ko.html
- Learn Git Branching: https://learngitbranching.js.org/?locale=ko
- GitHub 공식 시작 가이드: https://docs.github.com/ko/get-started/start-your-journey/hello-world

### 추가 읽을거리
- Google DORA 2023 보고서 (문서화와 성과)
- LangChain State of AI Agents 2025

---

## 9. 핵심 비유 모음 (Day 4)

| 개념 | 비유 | 한 줄 설명 |
|------|------|----------|
| Context Engineering | 업무 매뉴얼 만들기 | AI가 참고할 맥락을 설계 |
| Compound Engineering | 복리 이자 | 조금씩 고치면 나중에 크게 돌아옴 |
| 풀 사이클 | 요리 개선 과정 | 만들고 → 먹어보고 → 부족한 점 찾고 → 레시피 수정 |
| Repository | 프로젝트의 집 | 모든 파일이 사는 곳 |
| Commit | 게임 세이브 | 잘 되는 시점에 저장 |
| Branch | 실험용 복사본 | 원본 안 건드리고 시도 |
| Pull Request | 결재 문서 | "이렇게 바꿔봤는데 봐줘" |
| git | 실행 취소의 끝판왕 | 뭘 해도 돌아갈 수 있음 |
| 스킬 vs 서비스 | 글 초안 vs 블로그 발행 | 나만 쓰는 것 vs 세상에 공개 |
| GitHub | 작가의 작업실 | 버전 관리 + 협업 |
| Vercel | 자동 발행 시스템 | GitHub에 올리면 자동으로 웹사이트로 |
| Supabase | 독자 관리 + 데이터 | 방문자, 좋아요, 검색 데이터 관리 |
